<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: PcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00047.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00163.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00097_source.html">PcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00047.png" usemap="#PcapLiveDevice_map" alt=""/>
  <map id="PcapLiveDevice_map" name="PcapLiveDevice_map">
<area href="a00027.html" alt="IPcapDevice" shape="rect" coords="68,0,194,24"/>
<area href="a00050.html" alt="PcapRemoteDevice" shape="rect" coords="0,112,126,136"/>
<area href="a00078.html" alt="WinPcapLiveDevice" shape="rect" coords="136,112,262,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a201c04fe21184602ce48fb799b9bd7d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a> { <a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7a63f2e3a3e267195f84cff2adb2493a6c">LibPcapDevice</a>, 
<a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7aa09f95e4cf5b79cce8a5551e760ca204">WinPcapDevice</a>, 
<a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7a9fb6a9d0724e2c3698dbccd775bd66a2">RemoteDevice</a>
 }</td></tr>
<tr class="separator:a201c04fe21184602ce48fb799b9bd7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b64fcba0e667fcc7457b2ab4a4e21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21">DeviceMode</a> { <a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21ae39fe37c3af407e1a766c43dc717e8f8">Normal</a> = 0, 
<a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21a18306f1bc588dcecfd3c8455f779c5ec">Promiscuous</a> = 1
 }</td></tr>
<tr class="separator:a185b64fcba0e667fcc7457b2ab4a4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad48b57cb49c1384ce3730d8e295e66fd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad48b57cb49c1384ce3730d8e295e66fd">~PcapLiveDevice</a> ()</td></tr>
<tr class="separator:ad48b57cb49c1384ce3730d8e295e66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee16d25dcc202dab11a0fe2d162da9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aaee16d25dcc202dab11a0fe2d162da9d">getDeviceType</a> ()</td></tr>
<tr class="separator:aaee16d25dcc202dab11a0fe2d162da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e7cc84db0987f73976573bda8e357"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#af59e7cc84db0987f73976573bda8e357">getName</a> ()</td></tr>
<tr class="separator:af59e7cc84db0987f73976573bda8e357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ad41766f9887818b6f6cef904e366"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a300ad41766f9887818b6f6cef904e366">getDesc</a> ()</td></tr>
<tr class="separator:a300ad41766f9887818b6f6cef904e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5c7d6250a879306c7f34fa6bdb84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6eb5c7d6250a879306c7f34fa6bdb84a">getLoopback</a> ()</td></tr>
<tr class="separator:a6eb5c7d6250a879306c7f34fa6bdb84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50084c4f2f34c5eea2efa7ab1b2cd05"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ac50084c4f2f34c5eea2efa7ab1b2cd05">getMtu</a> ()</td></tr>
<tr class="separator:ac50084c4f2f34c5eea2efa7ab1b2cd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bd1951eab670a35f336773830c1f94"><td class="memItemLeft" align="right" valign="top">vector&lt; pcap_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a68bd1951eab670a35f336773830c1f94">getAddresses</a> ()</td></tr>
<tr class="separator:a68bd1951eab670a35f336773830c1f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62357fad523dfcc32b498371996f0a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00039.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad62357fad523dfcc32b498371996f0a6">getMacAddress</a> ()</td></tr>
<tr class="separator:ad62357fad523dfcc32b498371996f0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b987a553170405fe71c0aa13932520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00031.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ab6b987a553170405fe71c0aa13932520">getIPv4Address</a> ()</td></tr>
<tr class="separator:ab6b987a553170405fe71c0aa13932520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf27a7df25f12ba852c1cf89c7e971"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture</a> (<a class="el" href="a00097.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:ad8cf27a7df25f12ba852c1cf89c7e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d14b58bf781afc8f357bf25b83f0091"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0d14b58bf781afc8f357bf25b83f0091">startCapture</a> (<a class="el" href="a00097.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="a00097.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a0d14b58bf781afc8f357bf25b83f0091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d197b5d2162e7d5163d50761b273023"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7d197b5d2162e7d5163d50761b273023">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="a00097.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:a7d197b5d2162e7d5163d50761b273023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f4ae4316236d5ad016f20c0e319ec2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae4f4ae4316236d5ad016f20c0e319ec2">startCapture</a> (<a class="el" href="a00094.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:ae4f4ae4316236d5ad016f20c0e319ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd3f5a02456907a5b2f81dd9741a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture</a> ()</td></tr>
<tr class="separator:afdbd3f5a02456907a5b2f81dd9741a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b2d2c0a17950f59a364cc73edf79c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6e7b2d2c0a17950f59a364cc73edf79c">sendPacket</a> (<a class="el" href="a00063.html">RawPacket</a> const &amp;rawPacket)</td></tr>
<tr class="separator:a6e7b2d2c0a17950f59a364cc73edf79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99002c769a0f48e5a2875bba64f40db3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a99002c769a0f48e5a2875bba64f40db3">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:a99002c769a0f48e5a2875bba64f40db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a9fddf2bcf5f4c01c033fbf93d0453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa4a9fddf2bcf5f4c01c033fbf93d0453">sendPacket</a> (<a class="el" href="a00043.html">Packet</a> *packet)</td></tr>
<tr class="separator:aa4a9fddf2bcf5f4c01c033fbf93d0453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc03317266883c255e58b7ee2ddadade"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#adc03317266883c255e58b7ee2ddadade">sendPackets</a> (<a class="el" href="a00063.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:adc03317266883c255e58b7ee2ddadade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a23fcf16c66d8489b7d70502900b1ce"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a4a23fcf16c66d8489b7d70502900b1ce">sendPackets</a> (<a class="el" href="a00043.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:a4a23fcf16c66d8489b7d70502900b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea98417fc70ac84c0c47e95e7eb16c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a17ea98417fc70ac84c0c47e95e7eb16c">sendPackets</a> (const <a class="el" href="a00094.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:a17ea98417fc70ac84c0c47e95e7eb16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f7d0dcd5b00758e64e8af68d6d1e50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open</a> ()</td></tr>
<tr class="separator:a95f7d0dcd5b00758e64e8af68d6d1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee9fd9baee69b80f9b2d4327340f103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a4ee9fd9baee69b80f9b2d4327340f103">close</a> ()</td></tr>
<tr class="separator:a4ee9fd9baee69b80f9b2d4327340f103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dac2e4560b2fcc31db2dd71aebaf03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a89dac2e4560b2fcc31db2dd71aebaf03">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a89dac2e4560b2fcc31db2dd71aebaf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4c37258548c736033818de003f4c90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6d4c37258548c736033818de003f4c90">open</a> (<a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21">DeviceMode</a> mode)</td></tr>
<tr class="separator:a6d4c37258548c736033818de003f4c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00027"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00027')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00027.html">IPcapDevice</a></td></tr>
<tr class="memitem:ac8167b330a4ee85ab759facd0d4989bd inherit pub_methods_a00027"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html#ac8167b330a4ee85ab759facd0d4989bd">setFilter</a> (<a class="el" href="a00013.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:ac8167b330a4ee85ab759facd0d4989bd inherit pub_methods_a00027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e872140261fa1c824ae249f888d691 inherit pub_methods_a00027"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html#a35e872140261fa1c824ae249f888d691">setFilter</a> (string filterAsString)</td></tr>
<tr class="separator:a35e872140261fa1c824ae249f888d691 inherit pub_methods_a00027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a14c03ad4d351adefa4cd36ef4211ef70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c03ad4d351adefa4cd36ef4211ef70"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PcapLiveDeviceList</b></td></tr>
<tr class="separator:a14c03ad4d351adefa4cd36ef4211ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a network interface (each of the interfaces listed in ifconfig/ipconfig). This class wraps the libpcap capabilities of capturing packets from the network, filtering packets and sending packets back to the network. This class is relevant for Linux applications only. On Windows the <a class="el" href="a00078.html">WinPcapLiveDevice</a> (which inherits this class) is used. Both classes are almost similar in capabilities, the main difference between them is adapting some capabilities to the specific OS. This class cannot be instantiated by the user (it has a private constructor), as network interfaces aren't dynamic. Instances of this class (one instance per network interface) are created by <a class="el" href="a00048.html">PcapLiveDeviceList</a> singleton on application startup and the user can get access to them by using <a class="el" href="a00048.html">PcapLiveDeviceList</a> public methods such as <a class="el" href="a00048.html#a390c2c0cd28d808021a3264f56b084de">PcapLiveDeviceList::getPcapLiveDeviceByIp()</a><br />
 Main capabilities of this class:</p><ul>
<li>Get all available information for this network interfaces such as name, IP addresses, MAC address, MTU, etc. This information is taken from both libpcap and the OS</li>
<li>Capture packets from the network. Capturing is always conducted on a different thread. PcapPlusPlus creates this thread when capturing starts and kills it when capturing ends. This prevents the application from being stuck while waiting for packets or processing them. Currently only one capturing thread is allowed, so when the interface is in capture mode, no further capturing is allowed. In addition to capturing the user can get stats on packets that were received by the application, dropped by the NIC (due to full NIC buffers), etc. Stats collection can be initiated by the user by calling <a class="el" href="a00047.html#a89dac2e4560b2fcc31db2dd71aebaf03">getStatistics()</a> or be pushed to the user periodically by supplying a callback and a timeout to <a class="el" href="a00047.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture()</a></li>
<li>Send packets back to the network. Sending the packets is done on the caller thread. No additional threads are created for this task </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a185b64fcba0e667fcc7457b2ab4a4e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21">PcapLiveDevice::DeviceMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device capturing mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a185b64fcba0e667fcc7457b2ab4a4e21ae39fe37c3af407e1a766c43dc717e8f8"></a>Normal&#160;</td><td class="fielddoc">
<p>Only packets that their destination is this NIC are captured </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a185b64fcba0e667fcc7457b2ab4a4e21a18306f1bc588dcecfd3c8455f779c5ec"></a>Promiscuous&#160;</td><td class="fielddoc">
<p>All packets that arrive to the NIC are captured, even packets that their destination isn't this NIC </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a201c04fe21184602ce48fb799b9bd7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7">PcapLiveDevice::LiveDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the live device </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a201c04fe21184602ce48fb799b9bd7d7a63f2e3a3e267195f84cff2adb2493a6c"></a>LibPcapDevice&#160;</td><td class="fielddoc">
<p>libPcap live device </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a201c04fe21184602ce48fb799b9bd7d7aa09f95e4cf5b79cce8a5551e760ca204"></a>WinPcapDevice&#160;</td><td class="fielddoc">
<p>WinPcap live device </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a201c04fe21184602ce48fb799b9bd7d7a9fb6a9d0724e2c3698dbccd775bd66a2"></a>RemoteDevice&#160;</td><td class="fielddoc">
<p>WinPcap Remote Capture device </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad48b57cb49c1384ce3730d8e295e66fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PcapLiveDevice::~PcapLiveDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A destructor for this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4ee9fd9baee69b80f9b2d4327340f103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcapLiveDevice::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the device </p>

<p>Implements <a class="el" href="a00027.html#ad9dd73f0310fb6e3924fabb4e2542ef0">IPcapDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a68bd1951eab670a35f336773830c1f94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pcap_addr_t&gt;&amp; PcapLiveDevice::getAddresses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector containing all addresses defined for this interface, each in pcap_addr_t struct </dd></dl>

</div>
</div>
<a class="anchor" id="a300ad41766f9887818b6f6cef904e366"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PcapLiveDevice::getDesc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A human-readable description of the device, taken from pcap_if_t-&gt;description. May be NULL in some interfaces </dd></dl>

</div>
</div>
<a class="anchor" id="aaee16d25dcc202dab11a0fe2d162da9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00047.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a> PcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap or a remote device) </dd></dl>

<p>Reimplemented in <a class="el" href="a00050.html#ac09338c44301f7cdb9b833497641139f">PcapRemoteDevice</a>, and <a class="el" href="a00078.html#ad85b0bda8aa32772c3c0b4ddd6a36ea2">WinPcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ab6b987a553170405fe71c0aa13932520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">IPv4Address</a> PcapLiveDevice::getIPv4Address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The IPv4 address for this interface. If multiple IPv4 addresses are defined for this interface, the first will be picked. If no IPv4 addresses are defined, a zeroed IPv4 address (<a class="el" href="a00031.html#a29833df4aff7a34168268bfb739ef759">IPv4Address::Zero</a>) will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb5c7d6250a879306c7f34fa6bdb84a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::getLoopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this interface is a loopback interface, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad62357fad523dfcc32b498371996f0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00039.html">MacAddress</a> PcapLiveDevice::getMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The MAC address for this interface </dd></dl>

<p>Reimplemented in <a class="el" href="a00050.html#a57d8b6fc5eadc45214d1b1e0d166356c">PcapRemoteDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac50084c4f2f34c5eea2efa7ab1b2cd05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t PcapLiveDevice::getMtu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device's maximum transmission unit (MTU) in bytes </dd></dl>

<p>Reimplemented in <a class="el" href="a00050.html#a1edc9591657c5b8551b41ee87d85a77f">PcapRemoteDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af59e7cc84db0987f73976573bda8e357"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PcapLiveDevice::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name of the device (e.g eth0), taken from pcap_if_t-&gt;name </dd></dl>

</div>
</div>
<a class="anchor" id="a89dac2e4560b2fcc31db2dd71aebaf03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PcapLiveDevice::getStatistics </td>
          <td>(</td>
          <td class="paramtype">pcap_stat &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get statistics from device:</p><ul>
<li>pcap_stat::ps_recv: number of packets received</li>
<li>pcap_stat::ps_drop: number of packets dropped</li>
<li>pcap_stat::ps_ifdorp: number of packets dropped by interface <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>The stats struct where stats are returned </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p>Implements <a class="el" href="a00027.html#abfddac7872baed093efc622259f51fc6">IPcapDevice</a>.</p>

<p>Reimplemented in <a class="el" href="a00050.html#a8d10ffda65b9a4ba61d0193cf6b1872d">PcapRemoteDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a95f7d0dcd5b00758e64e8af68d6d1e50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the device using libpcap pcap_open_live. Opening the device only makes the device ready for use, it doesn't start packet capturing. For packet capturing the user should call <a class="el" href="a00047.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture()</a>. This implies that calling this method is a must before calling <a class="el" href="a00047.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture()</a> (otherwise <a class="el" href="a00047.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture()</a> will fail with a "device not open" error). The device is opened in promiscuous mode </p><dl class="section return"><dt>Returns</dt><dd>True if the device was opened successfully, false otherwise. When opening the device fails an error will be printed to log as well </dd></dl>

<p>Implements <a class="el" href="a00027.html#a94a6922dff88e4bea4b3904a60e6f0e9">IPcapDevice</a>.</p>

<p>Reimplemented in <a class="el" href="a00050.html#a2168e1c6e841dd9a9a5dcb8f0bb66ced">PcapRemoteDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a6d4c37258548c736033818de003f4c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00047.html#a185b64fcba0e667fcc7457b2ab4a4e21">DeviceMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a>, but enables to open the device in normal or promiscuous mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Normal or promiscuous mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e7b2d2c0a17950f59a364cc73edf79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00063.html">RawPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>rawPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a <a class="el" href="a00063.html">RawPacket</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacket</td><td>A reference to the raw packet to send. This method treats the raw packet as read-only, it doesn't change anything in it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a99002c769a0f48e5a2875bba64f40db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>packetDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a buffer containing packet raw data (including all layers) to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetData</td><td>The buffer containing the packet raw data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packetDataLength</td><td>The length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa4a9fddf2bcf5f4c01c033fbf93d0453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PcapLiveDevice::sendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a parsed <a class="el" href="a00043.html">Packet</a> to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>A pointer to the packet to send. This method treats the packet as read-only, it doesn't change anything in it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if packet was sent successfully. False will be returned in the following cases (relevant log error is printed in any case):<ul>
<li>Device is not opened</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adc03317266883c255e58b7ee2ddadade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00063.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="a00063.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The array of <a class="el" href="a00063.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a00078.html#ad1576486b7de3dd8dd9eca51d9bd05dc">WinPcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a4a23fcf16c66d8489b7d70502900b1ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">Packet</a> **&#160;</td>
          <td class="paramname"><em>packetsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of pointers to <a class="el" href="a00043.html">Packet</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packetsArr</td><td>The array of pointers to <a class="el" href="a00043.html">Packet</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a17ea98417fc70ac84c0c47e95e7eb16c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00094.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rawPackets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a vector of pointers to <a class="el" href="a00063.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPackets</td><td>The array of pointers to <a class="el" href="a00063.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is 0</li>
<li><a class="el" href="a00043.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00043.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad8cf27a7df25f12ba852c1cf89c7e971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00097.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). Each time a packet is captured the onPacketArrives callback is called. The capture is done on a new thread created by this method, meaning all callback calls are done in a thread other than the caller thread. Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0d14b58bf781afc8f357bf25b83f0091"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00097.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00097.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a00078.html#a83a5805972630d6071b07bc0f1d1de27">WinPcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a7d197b5d2162e7d5163d50761b273023"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00097.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a00078.html#ad8c8c56ec5b16cdd8c423274d8b4f07d">WinPcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae4f4ae4316236d5ad016f20c0e319ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="a00063.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a00047.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00047.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="a00063.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a00078.html#a79611cae573a93b09ee980c1af8f978a">WinPcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="afdbd3f5a02456907a5b2f81dd9741a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PcapLiveDevice::stopCapture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a currently running packet capture. This method terminates gracefully both packet capture thread and periodic stats collection thread (both if exist) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00047.html">PcapLiveDevice</a></li>
    <li class="footer">Generated on Wed Jul 1 2015 23:44:31 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
