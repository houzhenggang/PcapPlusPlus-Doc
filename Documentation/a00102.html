<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>PcapPlusPlus: WinPcapLiveDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PcapPlusPlus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00102.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00248.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WinPcapLiveDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00142_source.html">WinPcapLiveDevice.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for WinPcapLiveDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00102.png" usemap="#WinPcapLiveDevice_map" alt=""/>
  <map id="WinPcapLiveDevice_map" name="WinPcapLiveDevice_map">
<area href="a00070.html" alt="PcapLiveDevice" shape="rect" coords="0,56,126,80"/>
<area href="a00046.html" alt="IPcapDevice" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad85b0bda8aa32772c3c0b4ddd6a36ea2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ad85b0bda8aa32772c3c0b4ddd6a36ea2">getDeviceType</a> ()</td></tr>
<tr class="separator:ad85b0bda8aa32772c3c0b4ddd6a36ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a5805972630d6071b07bc0f1d1de27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a83a5805972630d6071b07bc0f1d1de27">startCapture</a> (<a class="el" href="a00127.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie, int intervalInSecondsToUpdateStats, <a class="el" href="a00127.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUsrrCookie)</td></tr>
<tr class="separator:a83a5805972630d6071b07bc0f1d1de27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c8c56ec5b16cdd8c423274d8b4f07d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ad8c8c56ec5b16cdd8c423274d8b4f07d">startCapture</a> (int intervalInSecondsToUpdateStats, <a class="el" href="a00127.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a> onStatsUpdate, void *onStatsUpdateUserCookie)</td></tr>
<tr class="separator:ad8c8c56ec5b16cdd8c423274d8b4f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79611cae573a93b09ee980c1af8f978a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a79611cae573a93b09ee980c1af8f978a">startCapture</a> (<a class="el" href="a00124.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;capturedPacketsVector)</td></tr>
<tr class="separator:a79611cae573a93b09ee980c1af8f978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1576486b7de3dd8dd9eca51d9bd05dc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#ad1576486b7de3dd8dd9eca51d9bd05dc">sendPackets</a> (<a class="el" href="a00087.html">RawPacket</a> *rawPacketsArr, int arrLength)</td></tr>
<tr class="separator:ad1576486b7de3dd8dd9eca51d9bd05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83fab2e5462bf6952389623ba69e0ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#aa83fab2e5462bf6952389623ba69e0ae">setMinAmountOfDataToCopyFromKernelToApplication</a> (int size)</td></tr>
<tr class="separator:aa83fab2e5462bf6952389623ba69e0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f8ebd9bba9bf1123c594f55ed0094"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html#a624f8ebd9bba9bf1123c594f55ed0094">getMinAmountOfDataToCopyFromKernelToApplication</a> ()</td></tr>
<tr class="separator:a624f8ebd9bba9bf1123c594f55ed0094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00070"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00070')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00070.html">PcapLiveDevice</a></td></tr>
<tr class="memitem:ad48b57cb49c1384ce3730d8e295e66fd inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ad48b57cb49c1384ce3730d8e295e66fd">~PcapLiveDevice</a> ()</td></tr>
<tr class="separator:ad48b57cb49c1384ce3730d8e295e66fd inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e7cc84db0987f73976573bda8e357 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#af59e7cc84db0987f73976573bda8e357">getName</a> ()</td></tr>
<tr class="separator:af59e7cc84db0987f73976573bda8e357 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ad41766f9887818b6f6cef904e366 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a300ad41766f9887818b6f6cef904e366">getDesc</a> ()</td></tr>
<tr class="separator:a300ad41766f9887818b6f6cef904e366 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5c7d6250a879306c7f34fa6bdb84a inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a6eb5c7d6250a879306c7f34fa6bdb84a">getLoopback</a> ()</td></tr>
<tr class="separator:a6eb5c7d6250a879306c7f34fa6bdb84a inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50084c4f2f34c5eea2efa7ab1b2cd05 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ac50084c4f2f34c5eea2efa7ab1b2cd05">getMtu</a> ()</td></tr>
<tr class="separator:ac50084c4f2f34c5eea2efa7ab1b2cd05 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad93e4ae406104e4627b911c5d3768c8 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pcap_addr_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aad93e4ae406104e4627b911c5d3768c8">getAddresses</a> ()</td></tr>
<tr class="separator:aad93e4ae406104e4627b911c5d3768c8 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62357fad523dfcc32b498371996f0a6 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00059.html">MacAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ad62357fad523dfcc32b498371996f0a6">getMacAddress</a> ()</td></tr>
<tr class="separator:ad62357fad523dfcc32b498371996f0a6 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b987a553170405fe71c0aa13932520 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00050.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ab6b987a553170405fe71c0aa13932520">getIPv4Address</a> ()</td></tr>
<tr class="separator:ab6b987a553170405fe71c0aa13932520 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24ee66cf26df433bc453716fcbdfa32 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00050.html">IPv4Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ab24ee66cf26df433bc453716fcbdfa32">getDefaultGateway</a> ()</td></tr>
<tr class="separator:ab24ee66cf26df433bc453716fcbdfa32 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58be70504374fea7d20ebc29da6a5e14 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00050.html">IPv4Address</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a58be70504374fea7d20ebc29da6a5e14">getDnsServers</a> ()</td></tr>
<tr class="separator:a58be70504374fea7d20ebc29da6a5e14 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cf27a7df25f12ba852c1cf89c7e971 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ad8cf27a7df25f12ba852c1cf89c7e971">startCapture</a> (<a class="el" href="a00127.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a> onPacketArrives, void *onPacketArrivesUserCookie)</td></tr>
<tr class="separator:ad8cf27a7df25f12ba852c1cf89c7e971 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd3f5a02456907a5b2f81dd9741a0c inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture</a> ()</td></tr>
<tr class="separator:afdbd3f5a02456907a5b2f81dd9741a0c inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b2d2c0a17950f59a364cc73edf79c inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a6e7b2d2c0a17950f59a364cc73edf79c">sendPacket</a> (<a class="el" href="a00087.html">RawPacket</a> const &amp;rawPacket)</td></tr>
<tr class="separator:a6e7b2d2c0a17950f59a364cc73edf79c inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99002c769a0f48e5a2875bba64f40db3 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a99002c769a0f48e5a2875bba64f40db3">sendPacket</a> (const uint8_t *packetData, int packetDataLength)</td></tr>
<tr class="separator:a99002c769a0f48e5a2875bba64f40db3 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a9fddf2bcf5f4c01c033fbf93d0453 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aa4a9fddf2bcf5f4c01c033fbf93d0453">sendPacket</a> (<a class="el" href="a00066.html">Packet</a> *packet)</td></tr>
<tr class="separator:aa4a9fddf2bcf5f4c01c033fbf93d0453 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a23fcf16c66d8489b7d70502900b1ce inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a4a23fcf16c66d8489b7d70502900b1ce">sendPackets</a> (<a class="el" href="a00066.html">Packet</a> **packetsArr, int arrLength)</td></tr>
<tr class="separator:a4a23fcf16c66d8489b7d70502900b1ce inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea98417fc70ac84c0c47e95e7eb16c inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a17ea98417fc70ac84c0c47e95e7eb16c">sendPackets</a> (const <a class="el" href="a00124.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;rawPackets)</td></tr>
<tr class="separator:a17ea98417fc70ac84c0c47e95e7eb16c inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f7d0dcd5b00758e64e8af68d6d1e50 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open</a> ()</td></tr>
<tr class="separator:a95f7d0dcd5b00758e64e8af68d6d1e50 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee9fd9baee69b80f9b2d4327340f103 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a4ee9fd9baee69b80f9b2d4327340f103">close</a> ()</td></tr>
<tr class="separator:a4ee9fd9baee69b80f9b2d4327340f103 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dac2e4560b2fcc31db2dd71aebaf03 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a89dac2e4560b2fcc31db2dd71aebaf03">getStatistics</a> (pcap_stat &amp;stats)</td></tr>
<tr class="separator:a89dac2e4560b2fcc31db2dd71aebaf03 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4c37258548c736033818de003f4c90 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a6d4c37258548c736033818de003f4c90">open</a> (<a class="el" href="a00070.html#a185b64fcba0e667fcc7457b2ab4a4e21">DeviceMode</a> mode)</td></tr>
<tr class="separator:a6d4c37258548c736033818de003f4c90 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00046"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00046')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00046.html">IPcapDevice</a></td></tr>
<tr class="memitem:a9f54bb88194b3374e92ab6533138a0a7 inherit pub_methods_a00046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html#a9f54bb88194b3374e92ab6533138a0a7">isOpened</a> ()</td></tr>
<tr class="separator:a9f54bb88194b3374e92ab6533138a0a7 inherit pub_methods_a00046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8167b330a4ee85ab759facd0d4989bd inherit pub_methods_a00046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html#ac8167b330a4ee85ab759facd0d4989bd">setFilter</a> (<a class="el" href="a00018.html">GeneralFilter</a> &amp;filter)</td></tr>
<tr class="separator:ac8167b330a4ee85ab759facd0d4989bd inherit pub_methods_a00046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cef54e472e5d9fdd6f20472a2b5bcd2 inherit pub_methods_a00046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html#a5cef54e472e5d9fdd6f20472a2b5bcd2">setFilter</a> (std::string filterAsString)</td></tr>
<tr class="separator:a5cef54e472e5d9fdd6f20472a2b5bcd2 inherit pub_methods_a00046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a14c03ad4d351adefa4cd36ef4211ef70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c03ad4d351adefa4cd36ef4211ef70"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PcapLiveDeviceList</b></td></tr>
<tr class="separator:a14c03ad4d351adefa4cd36ef4211ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_a00070"><td colspan="2" onclick="javascript:toggleInherit('pub_types_a00070')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="a00070.html">PcapLiveDevice</a></td></tr>
<tr class="memitem:a201c04fe21184602ce48fb799b9bd7d7 inherit pub_types_a00070"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a> { <a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7a63f2e3a3e267195f84cff2adb2493a6c">LibPcapDevice</a>, 
<a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7aa09f95e4cf5b79cce8a5551e760ca204">WinPcapDevice</a>, 
<a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7a9fb6a9d0724e2c3698dbccd775bd66a2">RemoteDevice</a>
 }</td></tr>
<tr class="separator:a201c04fe21184602ce48fb799b9bd7d7 inherit pub_types_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b64fcba0e667fcc7457b2ab4a4e21 inherit pub_types_a00070"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a185b64fcba0e667fcc7457b2ab4a4e21">DeviceMode</a> { <a class="el" href="a00070.html#a185b64fcba0e667fcc7457b2ab4a4e21ae39fe37c3af407e1a766c43dc717e8f8">Normal</a> = 0, 
<a class="el" href="a00070.html#a185b64fcba0e667fcc7457b2ab4a4e21a18306f1bc588dcecfd3c8455f779c5ec">Promiscuous</a> = 1
 }</td></tr>
<tr class="separator:a185b64fcba0e667fcc7457b2ab4a4e21 inherit pub_types_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that wraps a Windows network interface (each of the interfaces listed in ipconfig). This class is almost similar in its capabilities to <a class="el" href="a00070.html">PcapLiveDevice</a> (its parent class) with some small changes that mainly result from differences between libpcap and WinPcap. Please see the reference for <a class="el" href="a00070.html">PcapLiveDevice</a> for more details </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad85b0bda8aa32772c3c0b4ddd6a36ea2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00070.html#a201c04fe21184602ce48fb799b9bd7d7">LiveDeviceType</a> WinPcapLiveDevice::getDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type of the device (libPcap, WinPcap or a remote device) </dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#aaee16d25dcc202dab11a0fe2d162da9d">PcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a624f8ebd9bba9bf1123c594f55ed0094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WinPcapLiveDevice::getMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current amount of data in the kernel buffer that causes a read from the application to return (see also <a class="el" href="a00102.html#aa83fab2e5462bf6952389623ba69e0ae">setMinAmountOfDataToCopyFromKernelToApplication()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="ad1576486b7de3dd8dd9eca51d9bd05dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int WinPcapLiveDevice::sendPackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00087.html">RawPacket</a> *&#160;</td>
          <td class="paramname"><em>rawPacketsArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send an array of <a class="el" href="a00087.html">RawPacket</a> objects to the network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawPacketsArr</td><td>The array of <a class="el" href="a00087.html">RawPacket</a> objects to send. This method treats all packets as read-only, it doesn't change anything in them </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrLength</td><td>The length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets sent successfully. Sending a packet can fail if:<ul>
<li>Device is not opened. In this case no packets will be sent, return value will be 0</li>
<li><a class="el" href="a00066.html">Packet</a> length is 0</li>
<li><a class="el" href="a00066.html">Packet</a> length is larger than device MTU</li>
<li><a class="el" href="a00066.html">Packet</a> could not be sent due to some error in libpcap/WinPcap </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#adc03317266883c255e58b7ee2ddadade">PcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aa83fab2e5462bf6952389623ba69e0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WinPcapLiveDevice::setMinAmountOfDataToCopyFromKernelToApplication </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WinPcap has an ability (that doesn't exist in libpcap) to change the minimum amount of data in the kernel buffer that causes a read from the application to return (unless the timeout expires). Please see documentation for pcap_setmintocopy for more info. This method enables the user to change this size. Note the device must be open for this method to work </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size to set in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if set succeeded, false if the device is closed or if pcap_setmintocopy failed </dd></dl>

</div>
</div>
<a class="anchor" id="a83a5805972630d6071b07bc0f1d1de27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00127.html#a27f147465834b511910945added98cfa">OnPacketArrivesCallback</a>&#160;</td>
          <td class="paramname"><em>onPacketArrives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onPacketArrivesUserCookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection. Each time a packet is captured the onPacketArrives callback is called. In addition, each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called. Both the capture and periodic stats collection are done on new threads created by this method, each on a different thread, meaning all callback calls are done in threads other than the caller thread. Capture process and stats collection will stop and threads will be terminated when calling <a class="el" href="a00070.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00070.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrives</td><td>A callback that is called each time a packet is captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onPacketArrivesUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onPacketArrives callback each time it is called. This cookie is very useful for transferring objects that give context to the capture callback, for example: objects that counts packets, manages flow state or manages the application state according to the packet that was captured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#a0d14b58bf781afc8f357bf25b83f0091">PcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad8c8c56ec5b16cdd8c423274d8b4f07d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInSecondsToUpdateStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00127.html#a13a3124ab2d11ed3e37951e51dba5ebc">OnStatsUpdateCallback</a>&#160;</td>
          <td class="paramname"><em>onStatsUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>onStatsUpdateUserCookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device) with periodic stats collection only. This means that packets arriving to the network interface aren't delivered to the user but only counted. Each intervalInSecondsToUpdateStats seconds stats are collected from the device and the onStatsUpdate callback is called with the updated counters. The periodic stats collection is done on a new thread created by this method, meaning all callback calls are done in threads other than the caller thread. Stats collection will stop and threads will be terminated when calling <a class="el" href="a00070.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00070.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intervalInSecondsToUpdateStats</td><td>The interval in seconds to activate periodic stats collection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdate</td><td>A callback that will be called each time intervalInSecondsToUpdateStats expires and stats are collected. This callback will contain the collected stats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onStatsUpdateUserCookie</td><td>A pointer to a user provided object. This object will be transferred to the onStatsUpdate callback each time it is called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Stats collection thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#a7d197b5d2162e7d5163d50761b273023">PcapLiveDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a79611cae573a93b09ee980c1af8f978a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WinPcapLiveDevice::startCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00124.html#aa1427ba2ba13978d3b19b3fc7f25c15d">RawPacketVector</a> &amp;&#160;</td>
          <td class="paramname"><em>capturedPacketsVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start capturing packets on this network interface (device). All captured packets are added to capturedPacketsVector, so at the end of the capture (when calling <a class="el" href="a00070.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>) this vector contains pointers to all captured packets in the form of <a class="el" href="a00087.html">RawPacket</a>. The capture is done on a new thread created by this method, meaning capturedPacketsVector is updated from another thread other than the caller thread (so user should avoid changing or iterating this vector while capture is on). Capture process will stop and this capture thread will be terminated when calling <a class="el" href="a00070.html#afdbd3f5a02456907a5b2f81dd9741a0c">stopCapture()</a>. This method must be called after the device is opened (i.e the <a class="el" href="a00070.html#a95f7d0dcd5b00758e64e8af68d6d1e50">open()</a> method was called), otherwise an error will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capturedPacketsVector</td><td>A reference to a RawPacketVector, meaning a vector of pointer to <a class="el" href="a00087.html">RawPacket</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if capture started successfully, false if (relevant log error is printed in any case):<ul>
<li>Capture is already running</li>
<li>Device is not opened</li>
<li>Capture thread could not be created </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#ae4f4ae4316236d5ad016f20c0e319ec2">PcapLiveDevice</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00102.html">WinPcapLiveDevice</a></li>
    <li class="footer">Generated on Sun Jan 24 2016 15:20:55 for PcapPlusPlus by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
